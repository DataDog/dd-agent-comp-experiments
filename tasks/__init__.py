"""
Invoke entrypoint, import here all the tasks we want to make available
"""
import os

from invoke import task
from collections import namedtuple

Component = namedtuple('Component', ['path', 'doc', 'team'])
Bundle = namedtuple('Component', ['path', 'doc', 'team', 'components'])


def find_team(content):
    for l in content:
        if l.startswith('// team: '):
            return l.split(':', 2)[1].strip()


def find_doc(content):
    comment_block = []
    for l in content:
        if l.startswith('//'):
            comment_block.append(l[3:])
        elif l.startswith('package '):
            try:
                i = comment_block.index('')
                comment_block = comment_block[:i]
            except ValueError:
                pass
            return ''.join(comment_block).strip() + '\n'
        else:
            comment_block = []


def has_type_component(content):
    return any(l.startswith('type Component interface') for l in content)


def get_components_and_bundles(ctx):
    components = []
    bundles = []
    res = ctx.run('git ls-files comp/', hide=True)
    for file in res.stdout.splitlines():
        if file.endswith("/component.go"):
            content = [l for l in open(file, "r")]
            if not has_type_component(content):
                print(f"WARNING: {file} does not define a Component interface; skipping")
                pass

            path = file[:-len('/component.go')]
            team = find_team(content)
            doc = find_doc(content)

            if team is None:
                print(f"WARNING: {file} does not name a responsible team")

            # TODO: check that componentName is correct, used in fx.Module
            # TODO: check that 'var Module' exists

            components.append(Component(path, doc, team))

        elif file.endswith("/bundle.go"):
            content = [l for l in open(file, "r")]
            if has_type_component(content):
                print(f"WARNING: {file} defines a Component interface (bundles should not do so)")
                pass

            path = file[:-len('/bundle.go')]
            team = find_team(content)
            doc = find_doc(content)

            if team is None:
                print(f"WARNING: {file} does not name a responsible team")

            bundles.append(Bundle(path, doc, team, []))

    # assign components to bundles
    bundles = [
        Bundle(b.path, b.doc, b.team, [c for c in components if c.path.startswith(b.path)])
        for b in bundles
    ]

    # look for un-bundled components
    for c in components:
        if not any(c in b.components for b in bundles):
            print(f"WARNING: component {c.path} is not in any bundle")

    return sorted(components), sorted(bundles)


def make_components_md(bundles):
    pkg_root = 'github.com/djmitche/dd-agent-comp-experiments/'
    yield '# Agent Components'
    yield ''
    yield 'This file lists all components defined in this repository, with their package summary.'
    yield 'Click the links for more documentation.'
    yield ''
    for b in bundles:
        yield f'## [{b.path}](https://pkg.go.dev/{pkg_root}{b.path}@v0.0.2) (Component Bundle)'
        yield ''
        yield f'*Datadog Team*: {b.team}'
        yield ''
        yield b.doc
        for c in b.components:
            yield f'### [{c.path}](https://pkg.go.dev/{pkg_root}{c.path}@v0.0.2)'
            yield ''
            if c.team != b.team:
                yield f'*Datadog Team*: {c.team}'
                yield ''
            yield c.doc


def make_codeowners(bundles, components):
    # TODO: this ignores pkg/, task/, etc. -- it would need to merge its changes into the agent CODEOWNERS
    yield '# AUTOGENERATED CONTENT'

    # codeowners is parsed in a last-match-wins fashion, so put more-specific values (components) after
    # less-specific (bundles).  We include only components with a team different from their bundle, to
    # keep the file short.
    different_components = []
    for b in bundles:
        if b.team:
            yield f'{b.path} @DataDog/{b.team}'
        for c in b.components:
            if c.team != b.team:
                different_components.append(c)
    for c in different_components:
        if c.team:
            yield f'{c.path} @DataDog/{c.team}'


@task
def generate(ctx):
    components, bundles = get_components_and_bundles(ctx)

    with open("COMPONENTS.md", "w") as f:
        f.write('\n'.join(make_components_md(bundles)))

    with open(".github/CODEOWNERS", "w") as f:
        f.write('\n'.join(make_codeowners(bundles, components)))


@task
def build(ctx):
    binaries = [
        ('trace-agent', './cmd/traceagent'),
        ('agent', './cmd/agent'),
    ]
    for (binary, pkg) in binaries:
        ctx.run(f"go build -o {binary} {pkg}")
